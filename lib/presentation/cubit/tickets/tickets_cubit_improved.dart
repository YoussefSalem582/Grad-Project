import 'package:flutter/material.dart';
import 'package:flutter_bloc/flutter_bloc.dart';
import 'package:equatable/equatable.dart';

import '../../../domain/models/ticket.dart';
import '../../../domain/usecases/ticket_usecases.dart';

part 'tickets_state.dart';

class TicketsCubit extends Cubit<TicketsState> {
  final LoadTicketsUseCase _loadTicketsUseCase;
  final CreateTicketUseCase _createTicketUseCase;
  final UpdateTicketStatusUseCase _updateTicketStatusUseCase;
  final AssignTicketUseCase _assignTicketUseCase;
  final GetTicketStatisticsUseCase _getTicketStatisticsUseCase;

  TicketsCubit({
    required LoadTicketsUseCase loadTicketsUseCase,
    required CreateTicketUseCase createTicketUseCase,
    required UpdateTicketStatusUseCase updateTicketStatusUseCase,
    required AssignTicketUseCase assignTicketUseCase,
    required GetTicketStatisticsUseCase getTicketStatisticsUseCase,
  })  : _loadTicketsUseCase = loadTicketsUseCase,
        _createTicketUseCase = createTicketUseCase,
        _updateTicketStatusUseCase = updateTicketStatusUseCase,
        _assignTicketUseCase = assignTicketUseCase,
        _getTicketStatisticsUseCase = getTicketStatisticsUseCase,
        super(const TicketsInitial());

  // Current filter state
  TicketFilter _currentFilter = TicketFilter.empty();
  TicketSortBy _currentSortBy = TicketSortBy.createdDate;
  bool _isAdminView = false;

  // For legacy compatibility
  int _selectedFilterIndex = 0;

  // Getters for backward compatibility
  String get selectedFilter => _currentFilter.status?.displayName ?? 'all';
  String get selectedPriority => _currentFilter.priority?.displayName ?? 'all';
  String get searchQuery => _currentFilter.searchQuery;
  int get selectedFilterIndex => _selectedFilterIndex;

  /// Load tickets with current filter
  Future<void> loadAllTickets({bool isAdminView = false}) async {
    _isAdminView = isAdminView;
    emit(const TicketsLoading());

    try {
      // Adjust filter based on view type
      final filter = isAdminView 
          ? _currentFilter 
          : _currentFilter.copyWith(source: TicketSource.employee);

      final params = LoadTicketsParams(
        filter: filter,
        sortBy: _currentSortBy,
      );

      final result = await _loadTicketsUseCase(params);

      result.fold(
        (failure) => emit(TicketsError(failure.message)),
        (tickets) {
          if (isAdminView) {
            _emitAdminSuccess(tickets);
          } else {
            _emitEmployeeSuccess(tickets);
          }
        },
      );
    } catch (e) {
      emit(TicketsError('Failed to load tickets: $e'));
    }
  }

  /// Load tickets for employee view (backward compatibility)
  Future<void> loadTickets() async {
    await loadAllTickets(isAdminView: false);
  }

  /// Update filter and reload tickets
  Future<void> updateFilter(String filter, {bool isAdminView = true}) async {
    final status = filter == 'all' ? null : TicketStatus.fromString(filter);
    _currentFilter = _currentFilter.copyWith(status: status);
    await loadAllTickets(isAdminView: isAdminView);
  }

  /// Update priority filter and reload tickets
  Future<void> updatePriorityFilter(String priority, {bool isAdminView = true}) async {
    final priorityEnum = priority == 'all' ? null : TicketPriority.fromString(priority);
    _currentFilter = _currentFilter.copyWith(priority: priorityEnum);
    await loadAllTickets(isAdminView: isAdminView);
  }

  /// Update search query and reload tickets
  Future<void> updateSearchQuery(String query, {bool isAdminView = true}) async {
    _currentFilter = _currentFilter.copyWith(searchQuery: query);
    await loadAllTickets(isAdminView: isAdminView);
  }

  /// Change filter for employee view (backward compatibility)
  Future<void> changeFilter(int filterIndex) async {
    _selectedFilterIndex = filterIndex;
    
    TicketStatus? status;
    switch (filterIndex) {
      case 1:
        status = TicketStatus.open;
        break;
      case 2:
        status = TicketStatus.inProgress;
        break;
      case 3:
        status = TicketStatus.resolved;
        break;
      default:
        status = null;
    }

    _currentFilter = _currentFilter.copyWith(status: status);
    await loadAllTickets(isAdminView: false);
  }

  /// Create new ticket
  Future<void> createTicket(Map<String, dynamic> ticketData) async {
    emit(const TicketsLoading());

    try {
      // Convert map to Ticket model
      final ticket = Ticket(
        id: '', // Will be generated by use case
        title: ticketData['title'] ?? '',
        description: ticketData['description'] ?? '',
        status: TicketStatus.open,
        priority: TicketPriority.fromString(ticketData['priority'] ?? 'Medium'),
        source: TicketSource.employee,
        customerName: ticketData['customerName'] ?? '',
        category: ticketData['category'] ?? 'General',
        createdAt: DateTime.now(),
        updatedAt: DateTime.now(),
        referenceUrl: ticketData['referenceUrl'],
      );

      final params = CreateTicketParams(ticket: ticket);
      final result = await _createTicketUseCase(params);

      result.fold(
        (failure) => emit(TicketsError(failure.message)),
        (createdTicket) async {
          // Reload tickets after creation
          await loadAllTickets(isAdminView: _isAdminView);
        },
      );
    } catch (e) {
      emit(TicketsError('Failed to create ticket: $e'));
    }
  }

  /// Assign ticket to user
  Future<void> assignTicket(String ticketId, String assignee, {bool isAdminView = true}) async {
    emit(const TicketsLoading());

    try {
      final params = AssignTicketParams(
        ticketId: ticketId,
        assigneeId: assignee,
      );

      final result = await _assignTicketUseCase(params);

      result.fold(
        (failure) => emit(TicketsError(failure.message)),
        (updatedTicket) async {
          await loadAllTickets(isAdminView: isAdminView);
        },
      );
    } catch (e) {
      emit(TicketsError('Failed to assign ticket: $e'));
    }
  }

  /// Update ticket status
  Future<void> updateTicketStatus(String ticketId, String status, {bool isAdminView = true}) async {
    if (!isAdminView) {
      // For employee view, show less loading
      try {
        final params = UpdateTicketStatusParams(
          ticketId: ticketId,
          newStatus: TicketStatus.fromString(status),
        );

        await _updateTicketStatusUseCase(params);
        await loadAllTickets(isAdminView: false);
      } catch (e) {
        emit(TicketsError('Failed to update ticket status: $e'));
      }
      return;
    }

    emit(const TicketsLoading());

    try {
      final params = UpdateTicketStatusParams(
        ticketId: ticketId,
        newStatus: TicketStatus.fromString(status),
      );

      final result = await _updateTicketStatusUseCase(params);

      result.fold(
        (failure) => emit(TicketsError(failure.message)),
        (updatedTicket) async {
          await loadAllTickets(isAdminView: isAdminView);
        },
      );
    } catch (e) {
      emit(TicketsError('Failed to update ticket status: $e'));
    }
  }

  /// Update ticket priority (Admin functionality)
  Future<void> updateTicketPriority(String ticketId, String priority, {bool isAdminView = true}) async {
    emit(const TicketsLoading());

    try {
      // Note: This should use a separate UpdateTicketPriorityParams/UseCase
      // For now, using status use case as placeholder
      final params = UpdateTicketStatusParams(
        ticketId: ticketId,
        newStatus: TicketStatus.fromString(priority),
      );

      final result = await _updateTicketStatusUseCase(params);

      result.fold(
        (failure) => emit(TicketsError(failure.message)),
        (updatedTicket) async {
          await loadAllTickets(isAdminView: isAdminView);
        },
      );
    } catch (e) {
      emit(TicketsError('Failed to update ticket priority: $e'));
    }
  }

  /// Refresh tickets data
  Future<void> refreshTickets({bool isAdminView = true}) async {
    await loadAllTickets(isAdminView: isAdminView);
  }

  /// Set sort order
  void setSortBy(TicketSortBy sortBy) {
    _currentSortBy = sortBy;
    loadAllTickets(isAdminView: _isAdminView);
  }

  /// Clear all filters
  void clearFilters() {
    _currentFilter = TicketFilter.empty();
    _selectedFilterIndex = 0;
    loadAllTickets(isAdminView: _isAdminView);
  }

  /// Emit admin view success state
  void _emitAdminSuccess(List<Ticket> tickets) async {
    final statisticsResult = await _getTicketStatisticsUseCase(const NoParams());
    
    statisticsResult.fold(
      (failure) => emit(TicketsError(failure.message)),
      (statistics) {
        final ticketsData = AdminTicketsData(
          allTickets: tickets.map((t) => t.toMap()).toList(),
          filteredTickets: tickets.map((t) => t.toMap()).toList(),
          totalCount: statistics.totalCount,
          openCount: statistics.openCount,
          inProgressCount: statistics.inProgressCount,
          resolvedCount: statistics.resolvedCount,
          criticalCount: statistics.criticalPriorityCount,
        );
        emit(TicketsSuccess.admin(ticketsData));
      },
    );
  }

  /// Emit employee view success state
  void _emitEmployeeSuccess(List<Ticket> tickets) {
    final filterCounts = [
      tickets.length, // All
      tickets.where((t) => t.status == TicketStatus.open).length, // Open
      tickets.where((t) => t.status == TicketStatus.inProgress).length, // In Progress
      tickets.where((t) => t.status == TicketStatus.resolved).length, // Resolved
    ];

    final ticketsData = EmployeeTicketsData(
      tickets: tickets.map((t) => t.toMap()).toList(),
      filterCounts: filterCounts,
      selectedFilterIndex: _selectedFilterIndex,
    );
    emit(TicketsSuccess.employee(ticketsData));
  }
}
